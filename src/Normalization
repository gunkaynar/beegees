#!/usr/bin/env python
# coding: utf-8

# In[1]:


import numpy as np
from LoadImage import load_all_images


# In[2]:


# take created Red, Blue and Green arrays
r_array, g_array, b_array = load_all_images()


# In[3]:


# set each pixel value in (0,1) interval
norm_r_array = r_array/255.0
norm_g_array = g_array/255.0
norm_b_array = b_array/255.0


# In[4]:


# Create RGB matrix
RGBmatrix = np.array([norm_r_array,norm_g_array,norm_b_array])


# In[ ]:


# Convert RGB arrays to grayscale

# Method 1: Average of Channels
g_array = np.array([])
for i in range(len(r_array)):
    gs = (norm_r_array[i] + norm_g_array[i] + norm_b_array[i])/3
    g_array = np.append(g_array, gs)
g_array


# In[ ]:


# Method 2: Perceptual Luminance Corrected
g_array = np.array([])
for i in range(len(r_array)):
    gs = norm_r_array[i]*0.2126 + norm_g_array[i]*0.7152 + norm_b_array[i]*0.0722
    g_array = np.append(g_array, gs)
g_array


# In[ ]:


# Method 3: Gamma Compression (Long Calculation time)


# In[ ]:


# Method 4: Linear Approximation of Gamma Compression and Perceptual Luminance Corrected
g_array = np.array([])
for i in range(len(r_array)):
    gs = norm_r_array[i]*0.299 + norm_g_array[i]*0.587 + norm_b_array[i]*0.114
    g_array = np.append(g_array, gs)
g_array

# Most accurate (?) among all methods, so use this


# In[ ]:


def normalization():
    r_array, g_array, b_array = load_all_images()
    
    norm_r_array = r_array/255.0
    norm_g_array = g_array/255.0
    norm_b_array = b_array/255.0
    
    RGBmatrix = np.array([norm_r_array,norm_g_array,norm_b_array])
    
    g_array = np.array([])
    
    for i in range(len(RGBmatrix[0])):
        gs = norm_r_array[i]*0.299 + norm_g_array[i]*0.587 + norm_b_array[i]*0.114
        g_array = np.append(g_array, gs)
    
    return g_array

normalization()


# In[ ]:




